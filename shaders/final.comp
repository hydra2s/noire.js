#version 460 core
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference2 : enable
#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_EXT_shared_memory_block : enable

//
#include "include/math.glsl"
#include "include/noire.glsl"
#include "include/raytracing.glsl"

//
layout (local_size_x = 32, local_size_y = 6, local_size_z = 1) in;

//
vec4 tex2DBiLinear( in uint F, in vec2 texCoord_f )
{
    const ivec2 texCoord_i = ivec2(texCoord_f * vec2(width, height));
    const vec4 p0q0 = imageLoad(images[framebuffers[F]], texCoord_i);
    const vec4 p1q0 = imageLoad(images[framebuffers[F]], texCoord_i + ivec2(1, 0));
    const vec4 p0q1 = imageLoad(images[framebuffers[F]], texCoord_i + ivec2(0, 1));
    const vec4 p1q1 = imageLoad(images[framebuffers[F]], texCoord_i + ivec2(1, 1));
    const float a = fract( texCoord_f.x * width - 0.5f ); // Get Interpolation factor for X direction.
    const vec4 pInterp_q0 = mix( p0q0, p1q0, a ); // Interpolates top row in X direction.
    const vec4 pInterp_q1 = mix( p0q1, p1q1, a ); // Interpolates bottom row in X direction.
    const float b = fract( texCoord_f.y * height - 0.5f );// Get Interpolation factor for Y direction.
    return mix( pInterp_q0, pInterp_q1, b ); // Interpolate in Y direction.
}

//
vec4 smartDeNoise(uint tex, vec2 uv, float sigma, float kSigma, float threshold)
{
    float radius = round(kSigma*sigma);
    float radQ = radius * radius;

    float invSigmaQx2 = .5 / (sigma * sigma);      // 1.0 / (sigma^2 * 2.0)
    float invSigmaQx2PI = INV_PI * invSigmaQx2;    // 1/(2 * PI * sigma^2)

    float invThresholdSqx2 = .5 / (threshold * threshold);     // 1.0 / (sigma^2 * 2.0)
    float invThresholdSqrt2PI = INV_SQRT_OF_2PI / threshold;   // 1.0 / (sqrt(2*PI) * sigma^2)

    vec4 centrPx = tex2DBiLinear(tex,uv); 

    float zBuff = 0.0;
    vec4 aBuff = vec4(0.0);
    vec2 size = vec2(imageSize(images[framebuffers[tex]]));

    vec2 d;
    for (d.x=-radius; d.x <= radius; d.x++) {
        float pt = sqrt(radQ-d.x*d.x);       // pt = yRadius: have circular trend
        for (d.y=-pt; d.y <= pt; d.y++) {
            float blurFactor = exp( -dot(d , d) * invSigmaQx2 ) * invSigmaQx2PI;

            vec4 walkPx =  tex2DBiLinear(tex,uv+d/size);
            vec4 dC = walkPx-centrPx;
            float deltaFactor = exp( -dot(dC, dC) * invThresholdSqx2) * invThresholdSqrt2PI * blurFactor;

            zBuff += deltaFactor;
            aBuff += deltaFactor*walkPx;
        }
    }
    return aBuff/zBuff;
}



vec3 denoiseDiffuse(in ivec2 fragCoord) {
    float denoiseStrength = 1.0f;

    vec2 offset[25];
    offset[0] = vec2(-2,-2);
    offset[1] = vec2(-1,-2);
    offset[2] = vec2(0,-2);
    offset[3] = vec2(1,-2);
    offset[4] = vec2(2,-2);
    
    offset[5] = vec2(-2,-1);
    offset[6] = vec2(-1,-1);
    offset[7] = vec2(0,-1);
    offset[8] = vec2(1,-1);
    offset[9] = vec2(2,-1);
    
    offset[10] = vec2(-2,0);
    offset[11] = vec2(-1,0);
    offset[12] = vec2(0,0);
    offset[13] = vec2(1,0);
    offset[14] = vec2(2,0);
    
    offset[15] = vec2(-2,1);
    offset[16] = vec2(-1,1);
    offset[17] = vec2(0,1);
    offset[18] = vec2(1,1);
    offset[19] = vec2(2,1);
    
    offset[20] = vec2(-2,2);
    offset[21] = vec2(-1,2);
    offset[22] = vec2(0,2);
    offset[23] = vec2(1,2);
    offset[24] = vec2(2,2);
    
    
    float kernel[25];
    kernel[0] = 1.0f/256.0f;
    kernel[1] = 1.0f/64.0f;
    kernel[2] = 3.0f/128.0f;
    kernel[3] = 1.0f/64.0f;
    kernel[4] = 1.0f/256.0f;
    
    kernel[5] = 1.0f/64.0f;
    kernel[6] = 1.0f/16.0f;
    kernel[7] = 3.0f/32.0f;
    kernel[8] = 1.0f/16.0f;
    kernel[9] = 1.0f/64.0f;
    
    kernel[10] = 3.0f/128.0f;
    kernel[11] = 3.0f/32.0f;
    kernel[12] = 9.0f/64.0f;
    kernel[13] = 3.0f/32.0f;
    kernel[14] = 3.0f/128.0f;
    
    kernel[15] = 1.0f/64.0f;
    kernel[16] = 1.0f/16.0f;
    kernel[17] = 3.0f/32.0f;
    kernel[18] = 1.0f/16.0f;
    kernel[19] = 1.0f/64.0f;
    
    kernel[20] = 1.0f/256.0f;
    kernel[21] = 1.0f/64.0f;
    kernel[22] = 3.0f/128.0f;
    kernel[23] = 1.0f/64.0f;
    kernel[24] = 1.0f/256.0f;

    vec3 sum = vec3(0.0);
    float c_phi = 8.0;
    float n_phi = 1.0;
    //float p_phi = 0.3;
	vec3 cval = imageLoad(images[framebuffers[3]], fragCoord).xyz;
	vec3 nval = imageLoad(images[framebuffers[5]], fragCoord).xyz; nval.xyz = normalize(nval.xyz) * 0.5f + 0.5f;
	//vec4 pval = texelFetch(iChannel2, ivec2(fragCoord), 0);
    
    float cum_w = 0.0;
    for(int i=0; i<25; i++)
    {
        vec2 uv = fragCoord+offset[i]*denoiseStrength;
        
        vec3 ctmp = imageLoad(images[framebuffers[3]], ivec2(uv)).xyz;
        vec3 t = cval - ctmp;
        float dist2 = dot(t,t);
        float c_w = min(exp(-(dist2)/c_phi), 1.0);
        
        vec3 ntmp = imageLoad(images[framebuffers[5]], ivec2(uv)).xyz; ntmp.xyz = normalize(ntmp.xyz) * 0.5f + 0.5f;
        t = nval - ntmp;
        dist2 = max(dot(t,t), 0.0);
        float n_w = min(exp(-(dist2)/n_phi), 1.0);
        
        //vec4 ptmp = texelFetch(iChannel2, ivec2(uv), 0);
        //t = pval - ptmp;
        //dist2 = dot(t,t);
        //float p_w = min(exp(-(dist2)/p_phi), 1.0);
        
        //float weight = c_w*n_w*p_w;
        float weight = c_w*n_w;
        sum += ctmp*weight*kernel[i];
        cum_w += weight*kernel[i];
    }
    return (sum/cum_w).xyz;;
}



//
void main() {
    // TODO: linear interpolation support (virtual sampler)
    vec2 center =  (vec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y) + 0.5f) / vec2(windowWidth, windowHeight);
    vec3 fcolor = denoiseDiffuse(ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y));//smartDeNoise(3, center, 7.f, 1.f, 3.f).xyz;//tex2DBiLinear(3, center).xyz;
    //fcolor = fcolor * 0.5f + 0.5f;

    //
    imageStore(images[imageIndex], ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y), vec4(fcolor, 1.f));
}
