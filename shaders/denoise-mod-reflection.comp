#version 460 core
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference2 : enable
#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_EXT_shared_memory_block : enable
#extension GL_EXT_shader_atomic_float : enable

//
//#define A_GLSL
#define A_GPU
//#define A_HLSL_6_2
#define A_HALF
#define A_LONG

// broken AU1_AW4
//#define A_WAVE
//#define A_NO_16_BIT_CAST

//
#include "include/hlsl_map.glsl"
#include "include/math.glsl"
#include "include/noire.glsl"
//#include "include/ffx.glsl"

//
struct rproj {
    float nsimilarity;
    float dsimilarity;
    ivec2 forStoreToCurrent;
    vec2 motion;
    vec4 from;
    vec4 to;
    float T;
    bool isValid;
};

// подключаем премяшика
rproj reflectionReproj(in uvec2 coord) 
{
    // TODO: reproject by model previous transform
    float dirT = imageSetLoadPrevF(_DREPROJ, ivec2(coord.x, coord.y), 1).w;
    rproj ot; ot.isValid = false; ot.T = 0.f;//ot.T = 10000.f;
    //if (dirT > 0.001f) 
    {
        vec3 prevNormal = normalize(/*modelView[1] **/ vec4(imageSetLoadPrevF(_DOTHERS, ivec2(coord), 2).rgb, 0.f)).xyz;
        vec4 prevPView  = framebufferLoadF(_POSITION, ivec2(coord.x, coord.y), 1);
        vec4 prevCamera = unss(prevPView);
        vec4 prevOrigin = (prevCamera * modelViewInverse[1]);

        //
        vec3 prevDir    = normalize((modelView[1] * vec4(normalize(prevCamera.xyz), 0.f)).xyz);
        vec3 prevHitpos = prevOrigin.xyz /*+ prevDir * dirT*/;

        // TODO: reproject by model transform
        vec4 origin = prevOrigin;
        vec3 hitPos = prevHitpos;
        vec3 dir    = prevDir; // world space dir
        vec3 normal = prevNormal;

        //
        vec3 camOrigin = (origin * modelView[0]).xyz;
        vec3 camHitPos = (vec4(prevHitpos, 1.f) * modelView[0]).xyz;
        vec3 camDir    = normalize((modelViewInverse[0] * vec4(prevDir, 0.0f)).xyz);
        vec3 camNormal = normalize((modelViewInverse[0] * vec4(prevNormal, 0.f)).xyz);
        vec4 hview     = ss(vec4(camHitPos, 1.f));

        //
        vec3 point = find_reflection_incident_point((vec4(0.f.xxx, 1.f) * modelViewInverse[0]).xyz, hitPos, origin.xyz, normal.xyz);
        vec4 pview = ss((vec4(point, 1.f) * modelView[0]));

        vec3 pnormal = normalize((/*modelView[0] **/ vec4(imageSetLoadF(_DOTHERS, ivec2(unorm(pview.xy)*vec2(width,height)), 2).rgb, 0.f)).xyz).xyz;

        // may have threading conflict
        ot.forStoreToCurrent = ivec2(pview.xy * vec2(width, height));
        ot.nsimilarity = dot(pnormal, normal);
        //ot.dsimilarity = abs(pview.z - hview.z);
        ot.motion = unorm(pview.xyz).xy - unorm(prevPView.xyz).xy;
        ot.from = prevPView;
        ot.to = pview;
        ot.isValid = true;
        ot.T = 0.f;//distance(hitPos.xyz, point.xyz);
    }
    return ot;
}

//
void accumulate(in rproj prj) {
    //prj.to.y *= -1.f;
    //prj.from.y *= -1.f;
    ivec2 _to = ivec2(unorm(prj.to.xyz).xy*vec2(width,height));
    ivec2 _from = ivec2(unorm(prj.from.xyz).xy*vec2(width,height));

    //
    if (/*prj.isValid && imageSetLoadF(_METAPBR, _to, 1).r > 0.001f && prj.nsimilarity >= 0.9f*/true) {
        //imageSetAtomicAccumF(_FATOMIC, _to, imageSetLoadPrevF(_DIFFUSE, _from, 1), 1);

        //
        //imageSetStoreF(_DREPROJ, _to, vec4(0.0, 0.0, 0.0, prj.T), 2+1);
    }
}

//
layout(local_size_x = 32, local_size_y = 6, local_size_z = 1) in;
void main() {
    //
    ivec2 dispatchThreadId = ivec2(gl_GlobalInvocationID.xy);
    ivec2 groupThreadId = ivec2(gl_LocalInvocationID.xy);
    uvec2 targetSize = uvec2(width, height);

    //
    accumulate(reflectionReproj(gl_GlobalInvocationID.xy));
}
