#version 460 core
#extension GL_GOOGLE_include_directive : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_ray_query : enable
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int16 : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference : enable
#extension GL_EXT_buffer_reference2 : enable
#extension GL_EXT_samplerless_texture_functions : enable

//
#include "include/math.glsl"
#include "include/noire.glsl"
#include "include/raytracing.glsl"

//
layout (local_size_x = 32, local_size_y = 4, local_size_z = 1) in;

//
void main() {
    //const vec3 bOrigin = divW(  vec4((vec2(gl_GlobalInvocationID.xy) / vec2(width, height) * 2.0 - 1.0) * vec2(1.f, 1.f), 0.0, 1.0) * inverse(perspective) * modelViewInverse).xyz;
    //const vec3 eOrigin = divW(  vec4((vec2(gl_GlobalInvocationID.xy) / vec2(width, height) * 2.0 - 1.0) * vec2(1.f, 1.f), 1.0, 1.0) * inverse(perspective) * modelViewInverse).xyz;

    //
    RayTracedData data;
    rasterize(data, gl_GlobalInvocationID.xy);//
    const vec3 worldNormal = data.surfaceNormal;
    vec3 lightPos = vec3(10, 100, 0);
    vec3 lightDir = normalize(lightPos - data.origin.xyz);  
    float diff = sqrt(max(dot(data.surfaceNormal, lightDir), 0.0));
    vec3 diffuseCol = data.diffuse.xyz * (diff + 0.2f);
    const vec3 reflDir = normalize(reflect(data.dir, worldNormal));
    float fresnel = pow(1.f - max(dot(data.surfaceNormal.xyz, reflDir.xyz), 0.f), 2.f) * 0.9f + 0.1f;

    //
    const float epsilon = 0.001f * pow(data.originalOrigin.z, 256.f); // TODO: use depth for correct epsilon
    rayTrace(data, data.origin.xyz + worldNormal * epsilon, data.origin.xyz + worldNormal * epsilon + reflDir * 10000.f, reflDir);
    vec3 reflLightDir = normalize(lightPos - data.origin.xyz);
    float reflDiff = sqrt(max(dot(data.surfaceNormal, reflLightDir), 0.0));
    vec3 reflDiffuseCol = data.diffuse.xyz * (reflDiff + 0.2f);
    vec3 fcolor = mix(diffuseCol, reflDiffuseCol, fresnel);
    //vec3 fcolor = data.surfaceNormal * 0.5f + 0.5f;

    //
    imageStore(images[imageIndex], ivec2(gl_GlobalInvocationID.x, height-1-gl_GlobalInvocationID.y), vec4(fcolor, 1.f));
}
